<!-- --- START OF FILE ai_studio_code (31).html --- -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="logo.png">
    <title>Sculptor AI</title>
    <style>
        body {
            background-color: #050505;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            line-height: 1.4;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        #hero {
            height: 100vh;
            /* Full screen hero */
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            z-index: 10;
        }

        #canvas {
            font-family: 'Courier New', Courier, monospace;
            font-size: 8px;
            line-height: 8px;
            white-space: pre;
            text-align: center;
            text-shadow: 0 0 4px rgba(255, 255, 255, 0.4);
            margin: 0;
            display: block;
        }

        /* New Layout Styles */
        .content-container {
            width: 90vw;
            max-width: 1400px;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: flex-start;
            gap: 6rem;
            margin-bottom: 3rem;
            z-index: 20;
            position: relative;
        }

        @media (max-width: 768px) {
            .content-container {
                flex-direction: column;
                align-items: center;
            }

            .ascii-column {
                position: relative !important;
                top: auto !important;
                height: auto !important;
                margin-bottom: 4rem;
            }
        }

        /* Left Column: Sticky Spinning ASCII */
        .ascii-column {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            perspective: 1000px;
            position: sticky;
            top: 0;
            height: 100vh;
        }

        .spinning-ascii {
            font-family: 'Courier New', Courier, monospace;
            font-size: 10px;
            line-height: 10px;
            white-space: pre;
            color: #e0e0e0;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
            /* animation: spin 15s linear infinite; REMOVED STATIC SPIN */
            transform-style: preserve-3d;
        }

        #solid-logo-canvas {
            font-family: 'Courier New', Courier, monospace;
            font-size: 10px;
            line-height: 8px;
            white-space: pre;
            text-align: center;
            /* Subtle glow to help points bleed together visually */
            text-shadow: 0 0 2px rgba(255, 255, 255, 0.2);
        }

        @keyframes spin {
            from {
                transform: rotateY(0deg);
            }

            to {
                transform: rotateY(360deg);
            }
        }

        /* Right Column: Modern Text Content */
        .text-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10vh;
            /* Large gap for scrolling effect */
            padding-top: 20vh;
            padding-bottom: 5vh;
            max-width: 600px;
        }

        .scroll-section {
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 0.8s ease-out, transform 0.8s ease-out;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        .scroll-section.active {
            opacity: 1;
            transform: translateY(0);
        }

        .scroll-section h2 {
            font-size: 2.5rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(90deg, #fff, #888);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 700;
            letter-spacing: -0.02em;
        }

        .scroll-section h3 {
            font-size: 1.5rem;
            color: #fff;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .scroll-section p {
            font-size: 1.1rem;
            line-height: 1.6;
            color: #aaa;
            margin-bottom: 1rem;
        }

        .project-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1.5rem;
            border-radius: 12px;
            margin-bottom: 1.5rem;
            transition: transform 0.3s ease, background 0.3s ease;
        }

        .project-card:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.05);
        }

        .badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 100px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .badge.experimental {
            background: rgba(255, 95, 86, 0.2);
            color: #ff5f56;
            border: 1px solid rgba(255, 95, 86, 0.3);
        }

        .modern-link {
            display: inline-block;
            color: #27c93f;
            text-decoration: none;
            font-weight: 500;
            border-bottom: 1px solid transparent;
            transition: border-color 0.3s ease;
        }

        .modern-link:hover {
            border-bottom-color: #27c93f;
        }
    </style>
</head>

<body>

    <section id="hero">
        <pre id="canvas"></pre>
    </section>

    <div class="content-container">
        <div class="ascii-column">
            <pre id="solid-logo-canvas"></pre>
        </div>
        <div class="text-column">
            <section class="scroll-section">
                <h2>About Us</h2>
                <p>AI made by the rest of us. Building the future with open source principles.</p>
                <p>Transparency. Accessibility. Innovation.</p>
            </section>

            <section class="scroll-section">
                <h2>Projects</h2>
                <div class="project-card">
                    <h3>URSA</h3>
                    <p>Advanced Reasoning Model. State-of-the-art accuracy with open weights.</p>
                </div>
                <div class="project-card">
                    <h3>CONSTELLATION</h3>
                    <p>Flagship Open Source AI Platform. Local Model Support (Ollama) and Unified API Access.</p>
                </div>
            </section>

            <section class="scroll-section">
                <h2>Future Endeavors</h2>
                <h3>Project Sunfish</h3>
                <p>A next-generation diffusion model designed for high-fidelity text synthesis.</p>
                <p>Currently in active research phase. Focusing on architectural efficiency and style adaptability.</p>
                <span class="badge experimental">Experimental</span>
            </section>

            <section class="scroll-section">
                <h2>Source Code</h2>
                <p>Explore the codebase on GitHub.</p>
                <a href="https://github.com/Sculptor-AI/sculptor"
                    class="modern-link">github.com/Sculptor-AI/sculptor</a>
            </section>
        </div>
    </div>

    <script>
        // --- Configuration ---
        const SPHERE_RADIUS = 25.0;
        const NUM_POINTS = 32000;

        // --- Zoom Configuration ---
        const VIEW_DISTANCE_START = 110.0;
        const VIEW_DISTANCE_END = 210.0;

        // Standard shading characters for the Blob phase
        const SHADE_CHARS = " ·-:;=+*#%@";
        const CAM_YAW_SPEED = 0.01;

        // --- Timings (in frames) ---
        const TIME_BLOB_END = 180;
        const TIME_EXPLODE_END = 360;
        const TIME_GATHER_DURATION = 320;
        const TIME_TEXT_START = TIME_EXPLODE_END;

        let stateTimer = 0;

        // --- Geometry: The Blob ---
        const blobPoints = [];
        const phi = Math.PI * (3.0 - Math.sqrt(5.0));

        for (let i = 0; i < NUM_POINTS; i++) {
            const y = 1 - (i / (NUM_POINTS - 1)) * 2;
            const radiusAtY = Math.sqrt(1 - y * y);
            const theta = phi * i;
            blobPoints.push({
                x: Math.cos(theta) * radiusAtY,
                y: y,
                z: Math.sin(theta) * radiusAtY
            });
        }

        // --- Geometry: Target Generation ---
        const possibleTargets = [];

        // 1. Define the Logo
        const LOGO_ART = `
                                              .:=*##-
                                            :*@@@@@%-
                                      .    +@@@@@#-   -+####+=.
                                    =@@=  =@@@@@=   +%@@@@@@@@@%=
                                   +@@@=  #@@@@-  .#@@@@@@%##%%@%.
                                  :@@@@:  *@@@+  .%@@%+-.
                                  +@@@@=  -@@@.  #@%-    :-==+==:.
                                  =@@@@%   *@@.  %+  .=#@@@@@@@@@@*:
                                   #@@@@*   *@-  .   :+=--=+*%@@@@@@+
                                .   +@@@@#.  :.               .=%@@@@=
                               #@%-  .+%@@@+:          .*%%*=.   -%@@@.
                               #@@@*:   .-+##-           :*@@@#-  .#@@.
                               .@@@@@#=:               +.  -@@@@#.  ..
                                :%@@@@@@@##**##+   :.  %@-  -@@@@%.
                                 .=%@@@@@@@@%*-  .*@:  #@@.  +@@@@+
                                    .:---:.    .=%@#   %@@+  :@@@@+
                                     ..    .-+#@@@%.  =@@@%  .@@@@:
                                    *@@@@@@@@@@@@#.  -@@@@%  -@@@=
                                    :*%@@@@@@@@%=   =@@@@@=  :##=
                                       .-=+++-:  .=%@@@@@+
                                                :@@@@@%+:
                                                 =+=-.
        `;

        // 2. Define the Text Art (Specific Characters)
        const TEXT_ART = `
 .oooooo..o                       oooo                 .                      
d8P'    \`Y8                       \`888               .o8                      
Y88bo.       .ooooo.  oooo  oooo   888  oo.ooooo.  .o888oo  .ooooo.  oooo d8b 
 \`"Y8888o.  d88' \`"Y8 \`888  \`888   888   888' \`88b   888   d88' \`88b \`888""8P 
     \`"Y88b 888        888   888   888   888   888   888   888   888  888     
oo     .d8P 888   .o8  888   888   888   888   888   888 . 888   888  888     
8""88888P'  \`Y8bod8P'  \`V88V"V8P' o888o  888bod8P'   "888" \`Y8bod8P' d888b    
                                         888                                  
                                        o888o                                 
`;

        const GRID_X = 2.1;
        const GRID_Y = 4.0;

        // --- Helper: Generate Targets for Text Art ---
        function generateTextTargets() {
            let targets = [];
            const lines = TEXT_ART.split('\n');

            // Normalize indentation
            let minC = 9999;
            for (let r = 0; r < lines.length; r++) {
                let line = lines[r];
                for (let c = 0; c < line.length; c++) {
                    if (line[c] !== ' ' && line[c] !== undefined && line[c] !== '\n') {
                        if (c < minC) minC = c;
                    }
                }
            }
            if (minC === 9999) minC = 0;

            const heightOffset = lines.length / 2;
            let maxX = 0;

            for (let r = 0; r < lines.length; r++) {
                let line = lines[r];
                for (let c = 0; c < line.length; c++) {
                    let char = line[c];
                    if (char && char !== ' ' && char !== '\n') {

                        const baseX = (c - minC) * GRID_X;
                        const baseY = -(r - heightOffset) * GRID_Y;

                        if (baseX > maxX) maxX = baseX;

                        // VOXEL HEAVY LOGIC:
                        // 3x3 BLOCK of points per pixel + Deep Z Extrusion
                        const offsets = [-0.6, 0.0, 0.6];

                        for (let ox of offsets) {
                            for (let oy of offsets) {
                                // Extrude Z for depth
                                for (let zDepth = -3.0; zDepth <= 3.0; zDepth += 1.5) {
                                    targets.push({
                                        x: baseX + ox,
                                        y: baseY + oy,
                                        z: zDepth,
                                        isLogo: false,
                                        char: char // Store specific char
                                    });
                                }
                            }
                        }
                    }
                }
            }
            return { points: targets, width: maxX };
        }

        // --- Helper: Generate Targets for Logo ---
        function generateLogoTargets() {
            let targets = [];
            const lines = LOGO_ART.split('\n');

            let minC = 9999;
            for (let r = 0; r < lines.length; r++) {
                let line = lines[r];
                for (let c = 0; c < line.length; c++) {
                    if (line[c] !== ' ' && line[c] !== undefined) {
                        if (c < minC) minC = c;
                    }
                }
            }

            const logoHeightOffset = lines.length / 2;
            let maxX = 0;

            for (let r = 0; r < lines.length; r++) {
                let line = lines[r];
                for (let c = 0; c < line.length; c++) {
                    if (line[c] !== ' ' && line[c] !== undefined) {
                        let x = (c - minC) * GRID_X;
                        let y = -(r - logoHeightOffset) * GRID_Y;

                        if (x > maxX) maxX = x;

                        for (let z = -2.0; z <= 2.0; z += 1.0) {
                            targets.push({
                                x: x, y: y, z: z,
                                isLogo: true,
                                char: '@' // Force logo to be @
                            });
                        }
                    }
                }
            }
            return { points: targets, width: maxX };
        }

        // --- Combine and Position ---
        const textData = generateTextTargets();
        const logoData = generateLogoTargets();

        const GAP = 25.0;
        const totalWidth = logoData.width + GAP + textData.width;
        const startX = -totalWidth / 2;

        for (let p of logoData.points) {
            possibleTargets.push({
                x: p.x + startX,
                y: p.y,
                z: p.z,
                isLogo: true,
                char: p.char
            });
        }

        const textOffsetX = startX + logoData.width + GAP;
        for (let p of textData.points) {
            possibleTargets.push({
                x: p.x + textOffsetX,
                y: p.y,
                z: p.z,
                isLogo: false,
                char: p.char
            });
        }

        // Precompute the target layout once so the phase change doesn't hitch
        const sortedTargets = new Array(NUM_POINTS);
        for (let i = 0; i < NUM_POINTS; i++) {
            sortedTargets[i] = possibleTargets[i % possibleTargets.length];
        }
        sortedTargets.sort((a, b) => a.x - b.x);

        // --- Particle System ---
        let particles = [];
        for (let i = 0; i < NUM_POINTS; i++) {
            particles.push({
                x: 0, y: 0, z: 0,
                sx: 0, sy: 0, sz: 0,
                c1x: 0, c1y: 0, c1z: 0,
                c2x: 0, c2y: 0, c2z: 0,
                tx: 0, ty: 0, tz: 0,
                tChar: ' ', // Target Character

                vx: 0, vy: 0, vz: 0,
                baseX: blobPoints[i % blobPoints.length].x,
                baseY: blobPoints[i % blobPoints.length].y,
                baseZ: blobPoints[i % blobPoints.length].z
            });
        }

        // Pre-sort particle indices by their baseX so we can map targets without a runtime sort
        const particleOrder = Array.from({ length: NUM_POINTS }, (_, i) => i)
            .sort((a, b) => particles[a].baseX - particles[b].baseX);

        const screenElement = document.getElementById('canvas');
        const computedCanvasStyle = getComputedStyle(screenElement);

        // Measure character size accurately to avoid vertical clipping
        const measureElement = document.createElement('span');
        measureElement.style.fontFamily = computedCanvasStyle.fontFamily;
        measureElement.style.fontSize = computedCanvasStyle.fontSize;
        measureElement.style.lineHeight = computedCanvasStyle.lineHeight;
        measureElement.style.position = 'absolute';
        measureElement.style.visibility = 'hidden';
        measureElement.innerText = "X";
        document.body.appendChild(measureElement);
        let rect = measureElement.getBoundingClientRect();
        const charWidth = rect.width || 6;
        let charHeight = parseFloat(computedCanvasStyle.lineHeight);
        if (!charHeight || Number.isNaN(charHeight)) {
            charHeight = rect.height || 10;
        }
        document.body.removeChild(measureElement);

        let time = 0;
        let camPitch = 0;
        let camYaw = 0;

        let capturedPitch = 0;
        let capturedYaw = 0;
        let targetYaw = 0;
        let yawCorrection = 0;

        function easeInOutCubic(x) {
            return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
        }

        function cubicBezier(t, p0, p1, p2, p3) {
            const u = 1 - t;
            const tt = t * t;
            const uu = u * u;
            const uuu = uu * u;
            const ttt = tt * t;
            return (uuu * p0) + (3 * uu * t * p1) + (3 * u * tt * p2) + (ttt * p3);
        }

        function render() {
            const width = Math.max(1, Math.floor(window.innerWidth / charWidth));
            const height = Math.max(1, Math.floor(window.innerHeight / charHeight));
            const size = width * height;

            const zbuffer = new Float32Array(size).fill(-9999.0);
            const output = new Array(size).fill(' ');

            const K1 = Math.min(width, height) * 0.7;

            stateTimer++;

            // --- PHASE LOGIC ---

            if (stateTimer < TIME_BLOB_END) {
                // PHASE 1: BLOB
                camYaw += CAM_YAW_SPEED;
                camPitch = Math.sin(time * 0.5) * 0.3;

                const pulseFreq = 4.0;
                const pulseSpeed = time * 3.0;

                for (let p of particles) {
                    const noise = Math.sin(p.baseX * pulseFreq + pulseSpeed) *
                        Math.cos(p.baseY * pulseFreq + pulseSpeed);
                    const morph = 1.0 + (noise * 0.2);

                    p.x = p.baseX * SPHERE_RADIUS * morph;
                    p.y = p.baseY * SPHERE_RADIUS * morph;
                    p.z = p.baseZ * SPHERE_RADIUS * morph;
                }

            } else if (stateTimer < TIME_TEXT_START) {
                // PHASE 2: EXPLODE
                if (stateTimer === TIME_BLOB_END) {
                    for (let p of particles) {
                        p.vx = p.baseX * (Math.random() * 0.9 + 0.2);
                        p.vy = p.baseY * (Math.random() * 0.9 + 0.2);
                        p.vz = p.baseZ * (Math.random() * 0.9 + 0.2);
                    }
                }

                camYaw += CAM_YAW_SPEED;
                camPitch = Math.sin(time * 0.5) * 0.4;

                for (let p of particles) {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.z += p.vz;
                    p.vx *= 0.98;
                    p.vy *= 0.98;
                    p.vz *= 0.98;
                }

            } else {
                // PHASE 3: CONVERGENCE
                if (stateTimer === TIME_TEXT_START) {
                    capturedPitch = camPitch;
                    capturedYaw = camYaw;
                    targetYaw = Math.ceil((capturedYaw + 0.1) / (Math.PI * 2)) * (Math.PI * 2);
                    // Compute a correction so yaw keeps its existing velocity and still lands on target
                    yawCorrection = targetYaw - (capturedYaw + CAM_YAW_SPEED * TIME_GATHER_DURATION);

                    for (let i = 0; i < NUM_POINTS; i++) {
                        let p = particles[particleOrder[i]];
                        let t = sortedTargets[i];

                        // Assign the specific character
                        p.tChar = t.char;

                        let jitter = t.isLogo ? 0.05 : 0.1;

                        p.tx = t.x + (Math.random() - 0.5) * jitter;
                        p.ty = t.y + (Math.random() - 0.5) * jitter;
                        p.tz = t.z + (Math.random() - 0.5) * jitter;

                        p.sx = p.x;
                        p.sy = p.y;
                        p.sz = p.z;

                        const momentum = 120.0;
                        const spread = 40.0;
                        p.c1x = p.sx + (p.vx * momentum) + (Math.random() - 0.5) * spread;
                        p.c1y = p.sy + (p.vy * momentum) + (Math.random() - 0.5) * spread;
                        p.c1z = p.sz + (p.vz * momentum) + (Math.random() - 0.5) * spread;

                        const approach = 50.0;
                        p.c2x = p.tx + (Math.random() - 0.5) * approach;
                        p.c2y = p.ty + (Math.random() - 0.5) * approach;
                        p.c2z = p.tz + (Math.random() - 0.5) * approach;
                    }
                }

                let framesSinceStart = (stateTimer - TIME_TEXT_START);
                let progress = framesSinceStart / TIME_GATHER_DURATION;
                if (progress > 1.0) progress = 1.0;

                let ease = easeInOutCubic(progress);
                let framesClamped = Math.min(framesSinceStart, TIME_GATHER_DURATION);
                let baseYaw = capturedYaw + CAM_YAW_SPEED * framesClamped;
                camYaw = progress >= 1.0 ? targetYaw : baseYaw + yawCorrection * ease;
                camPitch = capturedPitch * (1.0 - ease);

                let t = progress;

                for (let p of particles) {
                    p.x = cubicBezier(t, p.sx, p.c1x, p.c2x, p.tx);
                    p.y = cubicBezier(t, p.sy, p.c1y, p.c2y, p.ty);
                    p.z = cubicBezier(t, p.sz, p.c1z, p.c2z, p.tz);
                }
            }

            // --- RENDER & LIGHTING ---

            let currentViewDist = VIEW_DISTANCE_START;
            let morphToText = 0.0; // 0.0 = Light Shading, 1.0 = Exact Char

            if (stateTimer > TIME_TEXT_START) {
                let p = (stateTimer - TIME_TEXT_START) / TIME_GATHER_DURATION;
                if (p > 1.0) p = 1.0;
                let zoomEase = easeInOutCubic(p);

                currentViewDist = VIEW_DISTANCE_START + (VIEW_DISTANCE_END - VIEW_DISTANCE_START) * zoomEase;

                // Ramp up texture morph
                morphToText = Math.max(0.0, (p - 0.2) * 1.5);
                if (morphToText > 1.0) morphToText = 1.0;
            }

            const cosA = Math.cos(camPitch), sinA = Math.sin(camPitch);
            const cosB = Math.cos(camYaw), sinB = Math.sin(camYaw);

            for (let i = 0; i < NUM_POINTS; i++) {
                let p = particles[i];

                let y1 = p.y * cosA - p.z * sinA;
                let z1 = p.y * sinA + p.z * cosA;
                let x1 = p.x;

                let x2 = x1 * cosB - y1 * sinB;
                let y2 = x1 * sinB + y1 * cosB;
                let z2 = z1;

                if (z2 > -currentViewDist + 1) {
                    let ooz = 1.0 / (currentViewDist + z2 / 4.0);

                    let xp = Math.floor(width / 2 + K1 * ooz * x2 * 2.0);
                    let yp = Math.floor(height / 2 - K1 * ooz * y2);

                    if (xp >= 0 && xp < width && yp >= 0 && yp < height) {
                        let idx = xp + yp * width;
                        if (ooz > zbuffer[idx]) {
                            zbuffer[idx] = ooz;

                            // 1. Calculate Standard Light Shade
                            let bBlob = (x2 * -0.5 + y2 * -0.5 + z2 * -1.0) / SPHERE_RADIUS + 0.3;
                            if (bBlob < 0) bBlob = 0; if (bBlob > 1) bBlob = 1;
                            let shadeChar = SHADE_CHARS[Math.floor(bBlob * (SHADE_CHARS.length - 1))];

                            // 2. Determine Final Char
                            let finalChar = shadeChar;

                            if (stateTimer > TIME_TEXT_START && p.tChar) {
                                // Transition from shading to actual character
                                if (Math.random() < morphToText) {
                                    finalChar = p.tChar;
                                }
                            }

                            output[idx] = finalChar;
                        }
                    }
                }
            }

            let frame = "";
            for (let k = 0; k < size; k++) {
                frame += output[k];
                if ((k + 1) % width === 0) frame += "\n";
            }
            screenElement.innerText = frame;

            time += 0.03;
            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);

        // --- SCROLL ANIMATION OBSERVER ---
        const observerOptions = {
            root: null,
            rootMargin: '0px',
            threshold: 0.2
        };

        const observer = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('active');
                }
            });
        }, observerOptions);

        document.querySelectorAll('.scroll-section').forEach(section => {
            observer.observe(section);
        });

        // --- SOLID 3D LOGO ANIMATION (SCOPED) ---
        (function () {
            // --- Configuration ---
            const VIEW_DISTANCE = 80.0;
            const ROTATION_SPEED = 0.004;
            const EXTRUSION_DEPTH = 7.0;  // Thicker

            // --- Density Settings ---
            // Lower Z_STEP = More layers (Solid sides)
            const Z_STEP = 0.25;
            // Higher XY_DENSITY = More points per character face (Solid front)
            const XY_DENSITY = 3;

            const SHADE_CHARS = " Â·-:;=+*#%@@";

            const LOGO_ART = `
                                              .:=*##-
                                            :*@@@@@%-
                                      .    +@@@@@#-   -+####+=.
                                    =@@=  =@@@@@=   +%@@@@@@@@@%=
                                   +@@@=  #@@@@-  .#@@@@@@%##%%@%.
                                  :@@@@:  *@@@+  .%@@%+-.
                                  +@@@@=  -@@@.  #@%-    :-==+==:.
                                  =@@@@%   *@@.  %+  .=#@@@@@@@@@@*:
                                   #@@@@*   *@-  .   :+=--=+*%@@@@@@+
                                .   +@@@@#.  :.               .=%@@@@=
                               #@%-  .+%@@@+:          .*%%*=.   -%@@@.
                               #@@@*:   .-+##-           :*@@@#-  .#@@.
                               .@@@@@#=:               +.  -@@@@#.  ..
                                :%@@@@@@@##**##+   :.  %@-  -@@@@%.
                                 .=%@@@@@@@@%*-  .*@:  #@@.  +@@@@+
                                    .:---:.    .=%@#   %@@+  :@@@@+
                                     ..    .-+#@@@%.  =@@@%  .@@@@:
                                    *@@@@@@@@@@@@#.  -@@@@%  -@@@=
                                    :*%@@@@@@@@%=   =@@@@@=  :##=
                                       .-=+++-:  .=%@@@@@+
                                                :@@@@@%+:
                                                 =+=-.
            `;

            const GRID_X = 1.8;
            const GRID_Y = 3.5;

            const particles = [];

            // --- Initialization ---

            function initLogo() {
                const lines = LOGO_ART.split('\n');

                // 1. Calculate Bounds
                let minC = 9999, maxC = 0;
                let minR = 9999, maxR = 0;

                for (let r = 0; r < lines.length; r++) {
                    let line = lines[r];
                    for (let c = 0; c < line.length; c++) {
                        if (line[c] !== ' ' && line[c] !== undefined && line[c] !== '\n') {
                            if (c < minC) minC = c;
                            if (c > maxC) maxC = c;
                            if (r < minR) minR = r;
                            if (r > maxR) maxR = r;
                        }
                    }
                }

                const centerX = (minC + maxC) / 2;
                const centerY = (minR + maxR) / 2;

                // 2. Generate Dense Voxels
                for (let r = 0; r < lines.length; r++) {
                    let line = lines[r];
                    for (let c = 0; c < line.length; c++) {
                        let char = line[c];
                        if (char && char !== ' ' && char !== '\n') {

                            const baseX = (c - centerX) * GRID_X;
                            const baseY = -(r - centerY) * GRID_Y;

                            // Create a dense volume for this character
                            // We loop Z in very small steps to create a solid "wall"
                            for (let z = -EXTRUSION_DEPTH; z <= EXTRUSION_DEPTH; z += Z_STEP) {

                                // Check if this layer is a "face" (front or back)
                                let isFace = (Math.abs(z) >= EXTRUSION_DEPTH - 0.5);

                                // Add multiple points per Z-layer to fill the X/Y area
                                // This ensures the object looks solid, not like a wireframe
                                for (let i = 0; i < XY_DENSITY; i++) {

                                    // Random spread within the character block
                                    // GRID_X/Y determines the block size, we fill about 90% of it
                                    let offsetX = (Math.random() - 0.5) * GRID_X * 1.1;
                                    let offsetY = (Math.random() - 0.5) * GRID_Y * 1.1;

                                    particles.push({
                                        x: baseX + offsetX,
                                        y: baseY + offsetY,
                                        z: z, // Keep Z strict for clean layering
                                        isFace: isFace
                                    });
                                }
                            }
                        }
                    }
                }
            }

            initLogo();

            // --- Rendering ---

            const screenElement = document.getElementById('solid-logo-canvas');
            if (!screenElement) return; // Safety check

            // Measure Char size
            const measureElement = document.createElement('span');
            measureElement.style.fontFamily = getComputedStyle(screenElement).fontFamily;
            measureElement.style.fontSize = getComputedStyle(screenElement).fontSize;
            measureElement.innerHTML = "X";
            document.body.appendChild(measureElement);
            let rect = measureElement.getBoundingClientRect();
            const charWidth = rect.width || 6;
            const charHeight = (rect.height * 0.9) || 10;
            document.body.removeChild(measureElement);

            let angle = 0;

            function render() {
                // Use container dimensions instead of window for the smaller logo
                const container = screenElement.parentElement;
                // Fallback to window if container has no size (though it should)
                const cWidth = container.clientWidth || window.innerWidth;
                const cHeight = container.clientHeight || window.innerHeight;

                const width = Math.max(1, Math.floor(cWidth / charWidth));
                const height = Math.max(1, Math.floor(cHeight / charHeight));
                const size = width * height;

                const zbuffer = new Float32Array(size).fill(-9999.0);
                const output = new Array(size).fill(' ');

                const K1 = Math.min(width, height) * 0.55;

                const cosT = Math.cos(angle);
                const sinT = Math.sin(angle);

                // Light Source
                const lx = 0.5;
                const ly = 0.5;
                const lz = -1.0;

                for (let i = 0; i < particles.length; i++) {
                    let p = particles[i];

                    // Rotate around Y
                    let x = p.x * cosT - p.z * sinT;
                    let z = p.x * sinT + p.z * cosT;
                    let y = p.y;

                    let zDist = VIEW_DISTANCE + z;

                    if (zDist > 1.0) {
                        let ooz = 1.0 / zDist;

                        let xp = Math.floor(width / 2 + K1 * ooz * x * 2.0);
                        let yp = Math.floor(height / 2 - K1 * ooz * y);

                        if (xp >= 0 && xp < width && yp >= 0 && yp < height) {
                            let idx = xp + yp * width;

                            if (ooz > zbuffer[idx]) {
                                zbuffer[idx] = ooz;

                                // Normal Calculation
                                let nx = 0;
                                let nz = 0;

                                if (p.isFace) {
                                    nx = sinT * (p.z > 0 ? 1 : -1);
                                    nz = cosT * (p.z > 0 ? 1 : -1);
                                } else {
                                    nx = cosT;
                                    nz = -sinT;
                                }

                                let dot = (nx * lx + nz * lz);
                                let depthShadow = (z + EXTRUSION_DEPTH) / (EXTRUSION_DEPTH * 2) * 0.4;

                                let intensity = dot + 0.55 - depthShadow;
                                if (intensity < 0) intensity = 0;
                                if (intensity >= 1) intensity = 0.99;

                                let charIdx = Math.floor(intensity * SHADE_CHARS.length);
                                output[idx] = SHADE_CHARS[charIdx];
                            }
                        }
                    }
                }

                let frame = "";
                for (let k = 0; k < size; k++) {
                    frame += output[k];
                    if ((k + 1) % width === 0) frame += "\n";
                }
                screenElement.innerText = frame;

                angle += ROTATION_SPEED;
                requestAnimationFrame(render);
            }

            requestAnimationFrame(render);
        })();




    </script>
</body>

</html>